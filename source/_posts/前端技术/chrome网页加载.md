---
title: 浏览器缓存
date: 2023-05-02 23:13:52
tags: 
  - 网页渲染
categories:
  - 前端技术
---

我们尝试从三个部分了解了浏览器加载和渲染一个网页的整个过程，我们可以从chrome导航网址中了解到chrome如何加载的网页，而在chrome解析页面部分我们可以了解到浏览器解析dom的过程和注意事项，最终我们可以通过chrome渲染页面部分大致理清浏览器是如何渲染出整个页面的。

<!-- more -->

## chrome导航网址的过程发生了什么

这一部分简单了解一下在用户输入一个网址或者进行页面跳转时，chrome本身所做的一些工作。

参考：

- [页面的生命周期](https://developer.chrome.com/blog/page-lifecycle-api/#overview_of_page_lifecycle_states_and_events)
- [深入了解现代网络浏览器-第二部分](https://developer.chrome.com/blog/inside-browser-part2/)

### 新tab的默认主页

打开一个新的tab，chrome有一个默认的主页，他也是一个网页，但是不属于任何站点，它理应存在一个渲染进程（因为需要渲染页面），可能所有默认的tab页面都共用同一个渲染进程，和网站的渲染进程不是同一个进程。

### 步骤一：在浏览器导航栏输入内容

此时可能是UI进程或UI线程处理相应事件，假设是UI线程，此时，他会判断这是一个网站导航还是一个搜索，来决定下一步，假设是一个网站导航。

### 步骤二：加载访问的站点数据

#### 开始加载

UI线程判断出这是一个站点导航，假设是访问的百度网站站点，此时，UI线程和专门处理网络请求的线程交互，通知网络线程加载这个站点数据，比如加载`https://baidu.com`这个url对于的那个资源（应该是html数据）。此时，网络线程会根据处理dns或者根据相应的协议建立tcp连接。

当网络线程加载时，此时可能会出现301重定向，如果是重定向，网络线程会和UI线程进行通信，则UI线程会更新导航栏UI，并且网络线程会继续加重定向的站点资源。

#### 处理加载的资源

当资源加载出来时，网络线程会判断（通过MIME类型）资源类型，比如如果是一个zip包，则是需要通知下载管理器，如果是一个html，则下一步就需要将数据传递给渲染器进程。

并且，这里也是检查数据内容安全性的地方，如果域和响应数据似乎与已知的恶意站点相匹配，则网络线程会发出警报以让UI线程显示警告页面。而且发生跨源数据读取（CORB）的跨站点数据也不会进入渲染器进程。

### 步骤三：准备渲染进程

当数据（站点html）准备好时（加载完毕，且安全），那么网络线程会通知UI线程数据已经OK，此时UI线程会准备一个渲染进程来渲染这个页面，可能是新的渲染进程也可能是已有的渲染进程），而网络加载可能有几百毫秒的延迟，此时有一个优化，在加载站点数据时，UI线程会同步为这个站点准备好渲染进程。如果一切按预期进行，当网络线程接收到数据时，渲染器进程已经处于待机状态。（而如果发生重定向，则重复走上一个步骤，这个准备好的渲染进程可能不会被使用）

### 步骤四：提交导航

此时数据和渲染进程准备好时，UI线程会通知渲染进程渲染这个站点页面并将加载的站点数据传递给渲染进程，这一步被叫为提交导航，此时，站点信息和前进后退（历史会话）就可用了，并且，为了持久化这些信息，会被存储到磁盘中。

渲染进程接收到html数据，解析该html文件，并加载这个站点中的其他资源（此时渲染进程会通过网络线程来加载），此为文档加载阶段，而渲染进程渲染页面所发生的具体事情，在下面会详细说明。

当渲染进程渲染完毕时，在执行完所有的onload事件后，会通知UI线程初始化加载完成，，此时UI线程更新页面的loading状态。这里只是初始化加载完成，因为后面渲染进程仍然可以加载资源并显示新的页面内容。

此时，整个页面的导航和显示基本上已经完成了。

### 在已经渲染完毕的页面上再次同导航栏进行导航

如果在已经渲染完毕的页面上再次通过导航栏访问其他站点，此时依然还是按照上面的几个步骤走相同的流程，只不过有几个点需要注意。

#### 页面beforeunload

如果站点页面存在beforeunload，那么此时会UI线程在重新导航之前会通过渲染进程检查当前页面的beforeunload事件（此特性可以实现“是否离开此页”的功能），此时，根据这个事件来决定是留在当前页面还是真的导航到其他站点。

#### 导航到其他站点的渲染进程

如果页面会导航到其他站点（不是当前站点），那么此时，会有一个新的渲染进程来渲染这个新的站点页面，而原有的渲染进程仍然保留并触发unload等事件，以便卸载该渲染进程，具体可以了解一下[页面的生命周期](https://developer.chrome.com/blog/page-lifecycle-api/#overview_of_page_lifecycle_states_and_events)

### 从页面内进入其他站点

如果进入到其他站点（不管是不是同一个站点）是由页面内发起的，则还是检查beforeunload，并直接走导航栏进入站点的步骤。唯一区别就是，导航请求是从渲染进程发起的。

### service worker

对这一套流程的最新影响是service worker，他可以决定资源是否进行缓存或者重新加载。而需要注意的是service worker是在渲染进程中执行的JavaScript代码，所以，UI线程会准备一个渲染进行来执行service worker，而UI线程是如何知道某个站点是否存在service worker的呢？这是在注册service worker时，网络线程会维护一个站点域名和service worker的表，通过这个来进行查询。

### chrome导航网址总结

从上面的过程中，我可以了解到大致chrome在导航一个网址是，它所做的工作有哪些。从这个流程中，我们也可以认识到chrome的多进程（甚至服务化）架构，从整理上看这非常符合高内聚、低耦合的思想。

## chrome解析页面

这一部分更加偏向于浏览器在解析页面dom时，所做的一些工作以及相关行为。包括解析时的资源加载、什么情况下会阻塞dom解析等等。

参考资源：

- [浏览器是如何解析html的？](https://juejin.cn/post/6844903745730396174)
- 参考：[渲染页面：浏览器的工作原理](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work#%E5%AF%BC%E8%88%AA)

### 从解析html到显式页面的大致步骤（webkit）

渲染进程得到html资源之后，会大致经过以下步骤来渲染该html页面：

1. 开始解析html为dom树（在此会有一个预加载扫描器来提前分析需要加载的资源）
2. 遇到资源时，加载资源，此时分为阻塞资源和非阻塞资源
3. 在构建dom树时，如果遇到了css样式标签或者样式资源，则会并行构建样式树
4. 遇到阻塞型资源则等待阻塞型资源完成后，再继续解析（浏览器会尝试尽快展示出页面内容，即使只有一部分，即使样式不是最终样式）
5. 待dom解析完成构建完dom树和css样式树后，合并并构建渲染树，计算布局
6. 绘制、显示

其中：

1. 待dom`解析`完成之后，会触发DOMContentLoaded事件，有两个条件：
   1. DOM 树完全构建
   2. 同步 JS 执行完
2. 待所有dom解析完成并且所有资源加载完成后（包括带async属性的script被加载且被执行后），会触发load事件

接下来一步一步分析

> ps: 注意上面的说明，解析dom树和渲染是两个步骤

### 开始解析dom

这一步，浏览器开始解析dom，浏览器会依照html规范，将获取到的html解析为dom，并构建一个dom树。这里唯一需要注意的是这里有一个优化，浏览器有一个叫做预加载扫描器的工具，来分析页面所需要的资源有哪些，并开始提前加载。

存在这个工具的原因在于，`解析dom`可能会被阻塞，而资源加载完全是可以异步并行加载的，没有必要等到解析dom时，遇到哪个资源再开始加载哪个资源，这样可能会导致有些资源要到很后面才会开始加载，这无法接受。而提前加载，可能等到解析器解析到这个资源时，已经被加载完成了，这样可以减少我们的页面整个渲染的时间。

#### 遇到阻塞型内容

当解析遇到阻塞型内容时，比如像内联script标签，不带async、defer属性的外联script脚本等，那么解析器会等待这些资源被加载以及被执行后，才会继续向下解析（也就是通常解析完成需要等待一般的js执行完成后）。阻塞型内容有下面几种：

- 内联js脚本
- 普通外联script脚本（不带async、defer属性的）
- javascript之前的外联css资源（特殊情况）

内联js和普通script脚本就不说了，这里是浏览器的一个防范措施，因为脚本可能想要修改（操作） DOM，甚至对其执行 document.write 操作，所以，dom解析会等待js资源的加载和执行完成后，才继续接下来的解析。这里js执行和解析dom都是在渲染进程的主线程中运行的，在解析dom之后再执行js，如果js操作dom，会导致页面再次发生变化，从而出现页面闪动（浏览器会尝试尽早显示出页面内容）

这里要注意资源的执行顺序，通常条件下浏览器会按照资源本身的解析顺序进行执行，而不是资源加载的顺序来执行（除了带有async属性的script脚本除外）

例如：js执行阻塞dom解析的简单示例：

```html
<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
  <link rel="icon" href="/favicon.ico">
</head>
<body>
<div id="app"></div>
<div>
  <h1>我是title</h1>
</div>
<script type="text/javascript">
  let i = 0
  function jsTestFn() {
    while (true) {
      i++;
      if (i > 1000000000) {
        break
      }
    }
  }
  jsTestFn();
</script>
</body>
</html>

```

![js执行阻塞dom解析](https://image.ncdsf.com/images/20250912153343547.png)

可以看到，上面的long task任务，其就是Parse HTML，而其中耗时最长的就是js的执行，当js这个长任务执行完成后，无论是否显式修改 DOM，浏览器都会触发一次 “轻量布局检查”（Layout任务），为了确认当前 DOM 树的结构完整性以及为后续 “DOMContentLoaded 后的首次渲染” 做准备，然后继续恢复Parse HTML任务，最终触发DOMContentLoaded事件。

然后就是所谓的“javascript之前的外联css资源”，本身外联css资源是不会阻塞dom的解析的，因为css解析和dom解析是分开的、并行的。但是呢，这里又涉及到浏览器的一个防范措施了（这也是为了符合html5的解析标准），因为js可能会操作之前dom的样式，此时，浏览器会维护css和js之间的位置关系，并在执行某个script之前阻塞它，等待这个script之前的那些css资源加载并执行完毕。而因为js被阻塞，且js又会阻塞dom（这上面列出的那些情况下），那么此时，css外联资源等于间接阻塞dom的解析。参考：[CSS到底会不会阻塞页面渲染](https://cloud.tencent.com/developer/article/1819747)。

#### 遇到非阻塞型内容

当解析遇到非阻塞型内容时，比如图像资源，外联css资源，那么解析器不会被阻塞，比如当遇到一个css外联标签时，解析器解析完该标签，发起css资源下载请求后，就会继续向下解析，不会等待css资源的下载和解析。非阻塞型内容有下面几种：

- 内联css样式
- 外联css样式（没有处在js脚本之前的外联css样式）
- 带有defer属性和async属性的外联script脚本
- 图片（img标签）
- iframe

正常内联css样式或者外联css样式都不会阻塞dom的解析（除了上文所说的“javascript之前的外联css资源”这种情况），css解析和dom解析是分开的，并行的，dom解析在遇到css样式时，会交由css解析器解析为样式树，然后继续向下解析。

图像和iframe都不会阻塞dom的解析。iframe甚至在最新的chrome中，会尝试使用一个新的渲染进程去渲染了，自然和本次渲染没有什么关系。

关于带有defer属性的script，你可以参考下文。这里需要注意的是，defer不会阻止dom解析，但是他是在DOMContentLoaded事件触发之前执行。

### 事件触发

- 在dom解析完毕，且需要执行的脚本执行完成后（带defer属性的脚本），会触发DOMContentLoaded事件。
- 在dom解析完毕，且所有的资源都加载完成后（比如图片资源），会触发Load事件

至此，页面的解析这一步算是完成了。不过页面的真正显示，可不是根据这两个事件来判断的。这涉及到浏览器的一些优化手段了。下文会说明。

一些注意事项：如果没有脚本阻止dom解析，那么可能页面能快速显示出来了，但是页面有可能处于不可交互状态，因为事件之类的绑定可能还没有完成（比如添加了async属性的script脚本还在加载中）。

### js脚本的async和defer以及动态脚本的特性

参考：[脚本：async，defer](https://zh.javascript.info/script-async-defer)

出现该特性的起因在于，我们通常的外联script脚本会阻塞dom的解析，而且此时脚本无法获取后面文档的dom元素。所以，提出了这两个属性来控制script脚本的执行时机。

#### defer脚本特性

- 不会阻塞页面dom的解析
- 会在`dom解析完毕后`、`触发DOMContentLoaded事件之前`执行
- defer脚本之间，按照脚本所在dom位置的`解析顺序`执行（注意，内联script总是先执行，因为script的解析是被包含在`当前dom解析位置后`中的）

> 如果 script 脚本没有 src，则会忽略 defer 特性。

#### async脚本特性

和async类似：

- 不会阻塞页面dom的解析
- 每个async脚本互相独立，只要脚本一加载完毕后就立即执行（此时，如果html没有被解析完成，则会暂停html的解析去执行该async脚本）
- 谁先加载完毕，谁先执行，没有任何关联
- DOMContentLoaded 和异步脚本不会彼此等待

> 如果 script 脚本没有 src，则会忽略 defer 特性。

### 动态脚本

我们可以使用 JavaScript 动态地创建一个脚本，并将其附加（append）到文档（document）中，默认情况下，动态脚本的行为是“异步/async”的：

- 它们不会等待任何东西，也没有什么东西会等它们。
- 先加载完成的脚本先执行（“加载优先”顺序）。

如果我们显式地设置了 script.async=false，则可以改变这个规则。然后脚本将按照脚本在文档中的顺序执行，就像 defer 那样。

注意：动态脚本无论如何，都不会阻止dom的解析。

### 一些思考

#### 如何优化页面显示

从上面的流程看，我们可以优化的手段有以下几种：

- 使用async和defer属性
- 将js放到body的底部，防止其阻塞dom解析（一般的html web页面）
- 优化css，以便可以尽快加载执行（例如预加载），以便减小阻塞js执行的时间。

### js是否会阻止页面显示

我们知道，有一个优化手段是：将js脚本加载放到页面底部，以让页面快速显示。这个优化的原理是什么？因为如果按照上文所述，dom在解析完成时，会被script脚本执行进行阻塞（没有defer和async属性），那么js脚本执行完成之前，dom解析任然未完成，那么为什么我们会看到页面呢？

这里涉及到两个点：

- 浏览器解析的渐进性特点：这里指浏览器会迫不及待的将解析出的内容显示出来。即浏览器会边渲染边解析，即使dom没有解析完成，但是有部分可见内容被解析选了，那么就可以显示出来。
- GUI 渲染和js执行是互斥的。如果是内联script脚本中的js代码执行，那么页面的渐进式渲染是会因此被阻塞的，页面UI无法被更新

参考如下代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
    div {
       background: gray;
    }
    </style>
</head>
<body>
    <div class="abc">this is first div</div>
    <!-- 加载需要1秒，然后alter打印 -->
    <script src="https://javascript.info/article/script-async-defer/long.js?speed=1"></script>
    
    <div>this is next dev</div>
    
    <script>
        let i = 0;
        // 这需要执行一段时间
        while (true) {
            i += 1;
            if (i > 2000000000) {
                console.log(123)
                break
            }
        }
    </script>
</body>
<!-- 这个样式不会影响浏览器显示第一个div元素 -->
<style>
.abc {
    font-size: 20px;
}
</style>
</html>
```

上面代码会有如下结果：

- 一开始页面只显示第一个背景为灰色，字体为正常的div元素，并触发FCP（虽然后续的dom解析被外联script阻塞了）
- 然后等待1秒钟左右，等待外联js加载并执行，然后继续解析
- 然后外联加载并执行完成之后，页面仍然没有变化，虽然第二个div被解析了，但是由于内联script执行`while(treu)`在执行，而js的执行和GPU渲染任务是互斥的，导致页面无法被重新渲染（即第二个div没有被渲染出来）。
- 等内联script执行完毕后，会继续解析，此时页面可以更新（渲染第二个div），并且同时解析到一个新的style，然后第一个div字体会变成20px
- 最后触发DOMContentLoaded和Load事件

我们可以通过Performance面板记录一下，你会发现，页面在非常早的时间就触发首屏渲染（first paint），此时页面显示出了第一个div元素及相关样式。不过代码最后的style标签还未被解析到，所以20px的字体样式还无法被应用。而中间很大部分时间是加载和执行脚本，等待脚本都加载完毕后，才触发DOMContentLoaded和Load事件。

![Performance面板记录](https://image.ncdsf.com/2022/06/30/20220630112500.png)

### chrome解析html总结

这里我们着重了解了浏览器在解析页面时的大致过程，这对我们优化网页加载有一定的启发。

## chrome渲染页面

参考资源：

- [构建对象模型](https://web.dev/critical-rendering-path-constructing-the-object-model/)
- [深入了解现代网络浏览器（第 3 部分）](https://developer.chrome.com/blog/inside-browser-part3/) 这篇文章来自chrome的博客

当浏览器加载好站点的数据，则会通知渲染进程解析渲染该站点的页面内容。这里我们就从渲染进程接收到了一个站点的html数据开始，描述渲染进程渲染页面时，内部做了哪些工作。

关于整体的浏览器打开一个网址时的大致流程，可以参考上面的内容

### 渲染进程的内部

渲染进程负责选项卡内发生的所有事情。其中，渲染进程的主线程会处理大部分的源码数据，而web worker、service worker则会运行于渲染进程的其他线程中，并且，像处理页面的光栅化、页面合成的工作也由渲染进程的其他线程负责。

> 现代浏览器的解析在不停的发展，且做了许多的优化，所以，下面所描述的不一定是现代浏览器最终的解析过程，中间可能有了许多的优化。这就导致了现代浏览器（有时间因素）真正完整的渲染页面的流程以及其中所做的优化是什么，很难说的清楚。这里也只是大概的说明一下解析流程

我们下面就从解析html开始，来描述一下浏览器渲染进程都做了哪些工作吧。

### dom的构建

当接收到导航消息以及html数据时，渲染进程主线程会将文本html解析成一个`dom树`（dom tree），dom是浏览器对页面的内部表示，提供给js的API。将html解析为dom，由[html标准](https://html.spec.whatwg.org/)定义。

在解析html的过程中，会遇到一些需要加载的资源，比如css，js，img这些，当渲染进程解析到这些资源时，会向通过`浏览器网络进程`请求这些资源。而这里由一个优化则是提供了一个`preload scanner`，翻译过来是预解析扫描器，他会扫描页面中，需要加载的资源，在解析dom的他同时就会去加载这些资源。这算是一个优化手段吧。

注意，如果解析到了js（script标签），渲染进程会暂停dom的解析，等待js加载完成及执行完成后，再继续解析html。更具体的解析dom过程，可以参考：《chrome解析页面》文档

### 解析css

dom树是页面的骨架，而css则是用来描述这个骨架的长什么样子，在渲染进程解析html为dom树的过程中，如果遇到了css或者css资源，那么会并行将css资源解析为样式树（cssom：css对象模型），这个过程是并行进行的。cssom和dom是完全独立的两个数据对象，cssom记录了它所设置的元素的样式内容。

而当一个dom元素在计算出这个元素的最终样式时，则会从一开始的通用规则开始递归地找到符合该元素规则的样式。注意，即使页面没有css代码或者资源，那么浏览器也会拥有针对所有dom的一个默认的样式表。

> 注意：css解析和dom解析这两个工作是并行的，所以“通常意义”上来说css的解析不会阻塞dom解析

### 渲染树

下面的一些步骤中，不同的一些博客文章中，所描述的内容不太一样。

以[深入了解现代网络浏览器（第 3 部分）](https://developer.chrome.com/blog/inside-browser-part3/) 为准吧。

现在渲染进程拥有了dom和cssom，但是他们之间还是相互独立的，需要需要将他们的信息合并在一起，这就是渲染树（chrome中的一些博客中也将其称为样式计算：style）。

这一个步骤所做的主要工作就是为了计算出每个节点的最终样式。

> 注：有些文章中描述渲染树时，在这个阶段会将不可见的元素给去掉，不将其作为渲染树的一部分，但是，chrome那篇博客中其实是将这一部分的工作放到了构建布局树阶段了。

我们在通过js的dom接口获取元素的样式、位置时，如果他是一个不可见元素（head或者display:none的元素），那么其位置信息都是为0，比如元素位置、宽高等等，都是0。就类似于窗口左上角的一个宽高为0的元素。

### 布局树

我们现在拥有的渲染树，知道最终的页面结构以及其样式，但是，对于一个页面来说，仅仅拥有渲染树，任然无法确定页面长什么样子。我们需要根据渲染树以及根据不同的布局规则来确定元素位置和几何形状，这就就是布局阶段。

布局树中，我们仅仅会保留可见dom，去除掉那些不可见的dom节点（比如link，head，script这种dom节点），而且，在此过程中，还会去除掉那些被设置为`display:none;`的元素。

注意：visibility: hidden不同于display: none。 前者虽然在页面中也是属于不可见，但是其仍然存在于布局树中，因为该元素仍然在页面中占据布局空间，只是看不到而已。而display: none就是纯粹的没有。它的位置信息、宽高等等信息都是0。

布局计算是非常复杂的。比如：你可能还需要计算dom元素到底应该在页面的哪个位置，元素之间是否会互相影响（比如流式布局），比如元素定位（Position）的规则，甚至一个元素的高度可能会根据文本内容多少而不同（多行文本）。

布局这里可能就需要应用到css的盒模型来确定元素的大小、以及所占据的空间了。而位置信息，则可能是按照一些布局规则：比如流式布局（文档流）、脱离文档流的部分定位（根据left、top这些信息）、flex、grid等等。

最终我们得到一个包含xy坐标、元素边界等信息的布局树。

> 重排/回流也是在这一步处理的

### 绘制记录（paint）

我们知道了页面最终的样子，但是绘制他们时，需要确定绘制记录，因为如果存在`z-index`的元素，如果绘制顺序不正确，那么页面显示是不正确的（比如不应该被覆盖的元素被其他元素覆盖了）。

所以，这里浏览器会遍历布局树，创建一个叫做绘制记录的东西。且此时应该是考虑到z-index等属性。这里就是为了确认绘制顺序，以便防止元素显示层级的错误。

这一步只是确认了元素的绘制顺序，以及页面的内容，但是并未转换为实际的像素点，而我们后面则需要将页面进行光栅化并显示出来。

### 显示页面：直接光栅化？

我们在处理了dom、cssom、渲染树、布局树以及绘制记录之后，我们就可以根据这些信息将其转换为页面上的像素点，这一步我们称之为光栅化。

那么，需要光栅化哪些内容呢？全部光栅化的成本太高，肯定不行，因为页面视口就那么大，看见的只是页面的一小部分，全部光栅化不值得。

或者就光栅化出现在视口部分的页面？如果页面滚动就再次光栅化出现的部分内容？这确实是之前chrome用的方案，但是现在使用了一个更加复杂的合成方案。

### 显示页面：合成页面和页面分层

合成是一种技术，chrome会将页面内容分为不同的层，然后分别将不同层进行光栅化。然后会在一个名为合成器线程中，将不同层合并为一个页面。而如果页面在滚动或者执行动画时，每次只需要移动图层然后合成一个新的帧即可。

这是一种绘制页面的方法。目前，chrome使用的就是这种页面显示的方法。

#### 分层

这里主要是为了确定将哪些元素分到那一层中，主线程会遍历布局树，来生成层树（layer tree）。你可以通过使用will-change CSS 中的属性来提示浏览器（注意，不要滥用，通常来说，浏览器都会较好的将页面分为合适的层）

#### 创建合成帧

一旦创建好了`图层树`并确定好了`绘制记录`，那么，主线程会将其交由合成器线程，由合成器线程光栅化每一层。

- 合成器会将每一层内容分割为多个小的部分（称之为瓦片），然后交由光栅线程去光栅化每个图块并缓存到gpu内存
- 这里合成器会做一个优化，以便可以优先将视口部分的部分进行光栅化。
- 当瓦片都被光栅化之后，就可以创建合成帧了，然后最终会提交GPU中来显示页面。如果页面变化，则会创建另外的一个合成帧并发送到GPU显示

这里的合成器是在不涉及主线程的情况下完成的。而dom解析、渲染树、布局树等操作是在主线程上的，他会被js的执行所阻塞。所以，仅仅涉及到合成的动画会被认为是效率最高的动画（如 transform 动画仅需在合层阶段调整图层位置，无需重新布局或绘制），可以参考：[如何创建高性能 CSS 动画](https://web.dev/animations-guide/)。而如果要涉及计算布局或者其他步骤，则必须涉及主线程了。

> 注意：只有满足特定条件的变化才会触发合成，这主要取决于变化是否涉及到合成层的变动。如果变化仅仅影响元素的非合成相关属性，如改变元素的文本内容、背景颜色、字体颜色等，这些变化只会触发重绘，而不会触发合成。因为这些变化不涉及合成层的移动、缩放或透明度调整等操作，浏览器只需要重新绘制受影响的元素，不需要进行图层的合并和调整。

### 渲染管道

上面的：`dom/css - 样式计算（渲染树）- 布局树 - 绘制（paint） - 合成。` 这几个步骤被称为渲染管道，后者的数据依赖前者。如果其中某一个步骤的数据变化了，那么对于受影响的部分需要从该步骤开始重新计算。

这里，绘制和页面合成的工作界定阶段还没有那么清楚，你可以将其简单界定为：

- 绘制：确定绘制顺序、元素分层、确定每层显示的内容
- 页面合成：光栅化每层页面、创建合成帧

只要元素外观改变了，比如元素背景颜色改变之后，则肯定需要涉及到重绘，即绘制阶段，如果其宽度变化了，则会触发布局、重绘。

一个修改样式，导致位置页面位置变化的示例：

![示例](https://image.ncdsf.com/2022/07/14/20220714135217.png)

### js操作dom和页面渲染的关联

在主线程执行js并操作dom时，dom的样式、属性的修改会被同步地更新到dom树、cssom上去。并且，有些js操作会触发样式计算和触发布局。

案例：[页面jank](https://googlechrome.github.io/devtools-samples/jank/)

如果在一开始修改了元素top，然后又用js获取元素top。其中第一步操作可能没有什么，但是第二步操作，浏览器就会触发元素的样式计算以及回流了，且是同步的，你可以从浏览器的火焰图中看到，在一个js任务中，可能会触发多次且同步执行样式计算和回流（layout），虽然回流影响的元素可能比较小，比如使用了绝对定位这种脱离默认布局流的，但是仍然触发了不是吗。不过这里只是说明触发样式计算、回流，不一定会触发绘制、页面合成去显示到页面上，因为不一定需要。

### 防止触发强制回流

浏览器的优化机制：现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！当你获取布局信息的操作的时候，会强制队列刷新来进行回流布局（不一定会重绘，因为是否重绘不会影响），因为他需要保证你获取到的dom元素的位置信息是最新的。

比如获取以下内容时：

- 元素宽高
- 所在的位置信息，相对于父元素、窗口等

### 更新渲染时的代价

当页面更新时（dom更新、样式更新），则会导致重新构建dom数（dom更新）、cssom树、然后重新构建渲染树，布局树，参考：[渲染管道](#渲染管道) 章节。

比如，你的页面在存在动画时时，如果要让动画以60fps每秒进行刷新以达到流畅的程度，那么这几个步骤至少也需要在16ms内完成，如果这些步骤无法在一帧（16ms）的时间内完成，那么就会导致动画卡顿，即：`页面janky`。

另外要注意的是，这些计算操作的执行是在主线程上完成的，而js的执行也是在主线程上完成的，这就意味着，你的js如果运行较长时间，那么就会阻塞你的这些计算操作，导致错过每一帧的更新。

通常，我们会优化js的部分，不让其阻塞这些计算操作：

- 较长的js任务执行可以将较长的js任务放到worker中
- 将任务分解为一个个的小任务，然后使用requestAnimationFrame让任务在下一次重绘之前被调用。当你准备更新动画时，通常会调用此方法。通常来说，每秒会被调用60次。
- 使用requestIdleCallback API，让任务在浏览器空闲的时间时运行。参考：[MDN requestIdleCallback](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback) 这样可以在主线程中执行后台任务或者低优先级任务

如果你是利用js处理动画，比如绘制canvas动画，那么就需要在60帧中的每一帧渲染之前，运行你的js来修改动画内容，此时就可以考虑requestAnimationFrame而不是requestIdleCallback，因为浏览器空闲时间不一定是在每一帧渲染的开头。而如果你只是想要单纯的不想让任务执行时间过长，阻塞页面响应，那么就可以考虑将任务分割并使用requestIdleCallback，这样既可以执行你的任务，也不会影响你的页面响应和页面渲染。

不用settimeout的原因在于它的帧率不一致：它的回调受浏览器宏任务阻塞应用，很容易错过下一帧的运行。

### 浏览器重绘和回流

参考：

- [你真的了解回流和重绘吗](https://segmentfault.com/a/1190000017329980)
- [面试经常提到的重排和重绘，你真的了解吗？](https://www.chenhanpeng.com/reflow-and-repaint/)

根据上面的浏览器渲染过程可知，回流应该是发生在布局阶段，也就是由于dom或者样式树改变导致页面布局需要重新计算时，会触发布局树的构建，此时，被称为回流。而重绘，你就粗略将其视为需要绘制新的页面内容就行了。
